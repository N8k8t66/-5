import tkinter as tk

maze = [
    ['0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0'],
    ['0','S','1','1','1','E','1','0','1','1','1','0','1','1','1','1','1','1','1','0'],
    ['0','1','0','0','0','0','1','0','1','0','1','0','1','0','0','0','0','0','1','0'],
    ['0','1','1','1','1','0','1','1','1','0','1','1','1','1','1','1','1','0','1','0'],
    ['0','0','0','0','1','0','0','0','1','0','0','0','0','0','0','0','1','0','1','0'],
    ['0','E','1','0','1','1','1','0','1','1','1','1','1','1','1','0','1','1','1','0'],
    ['0','1','0','0','0','0','1','0','0','0','0','0','0','0','1','0','0','0','1','0'],
    ['0','1','1','1','1','0','1','1','1','1','1','1','1','0','1','1','1','0','1','0'],
    ['0','0','0','0','1','0','0','0','1','0','0','0','1','0','0','0','1','0','1','0'],
    ['0','1','1','0','1','1','1','0','1','1','1','0','1','1','1','0','1','1','1','0'],
    ['0','E','0','0','0','0','1','0','1','0','E','0','1','0','0','0','1','0','0','0'],
    ['0','1','1','1','1','1','1','1','1','0','1','1','1','1','1','1','1','1','1','0'],
    ['0','1','0','0','0','0','0','0','1','0','0','0','0','0','0','0','0','0','1','0'],
    ['0','1','1','1','1','1','1','0','1','1','1','0','1','1','1','1','1','0','1','0'],
    ['0','1','0','0','0','0','1','0','0','0','1','0','1','0','0','0','1','0','1','0'],
    ['0','1','1','1','1','0','1','1','1','0','1','1','1','1','1','0','1','1','1','0'],
    ['0','E','0','0','1','0','0','0','1','0','0','0','1','0','0','0','1','0','0','0'],
    ['0','1','1','1','1','1','1','0','1','1','1','0','1','1','1','E','1','1','1','0'],
    ['0','1','0','0','0','0','1','0','1','0','1','0','1','0','0','0','0','0','E','0'],
    ['0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0'],
]

height = len(maze) 
width = len(maze[0]) 

cell_size = 20

main_window = tk.Tk()

window_width = width * cell_size
window_height = height * cell_size

screen_width = main_window.winfo_screenwidth()
screen_height = main_window.winfo_screenheight()

x_position = (screen_width - window_width) // 2
y_position = (screen_height - window_height) // 2

main_window.geometry(f"{window_width}x{window_height}+{x_position}+{y_position}")
main_window.title("Поиск выхода из лабиринта")

canvas = tk.Canvas(main_window, width=window_width, height=window_height, bg="white")
canvas.pack()

start_row = None  
start_column = None 
visited_cells = [] 
exit_found = False
exit_count = 0 

def find_start_position():
    global start_row, start_column
    
    print("Ищу стартовую позицию...")
    
    for row in range(height):
        for column in range(width):
            if maze[row][column] == 'S':
                start_row = row
                start_column = column
                print(f"Нашел старт! Строка: {start_row}, Столбец: {start_column}")
                return True
    
    print("Стартовая позиция не найдена!")
    return False

def draw_maze():
    canvas.delete("all")
  
    for row in range(height):
        for column in range(width):
            cell_value = maze[row][column]
          
            if cell_value == '0':
                cell_color = "black"
            elif cell_value == 'E':
                if (row, column) in visited_cells:
                    cell_color = "green"
                else:
                    cell_color = "red"
            elif cell_value == 'S':  # старт
                cell_color = "blue"
            else:  # путь (1)
                if (row, column) in visited_cells:
                    cell_color = "orange"
                else:
                    cell_color = "white"
            
            x1 = column * cell_size
            y1 = row * cell_size
            x2 = x1 + cell_size
            y2 = y1 + cell_size
          
            canvas.create_rectangle(x1, y1, x2, y2, fill=cell_color, outline="gray")
            
            canvas.create_text(x1 + cell_size/2, y1 + cell_size/2, text=f"{row},{column}", font=("Arial", 6))

def search_path(current_row, current_column):
    global exit_found, exit_count, visited_cells
    
    if exit_found:
        return True
    
    if maze[current_row][current_column] == '0':
        return False
    
    if (current_row, current_column) in visited_cells:
        return False
    
    visited_cells.append((current_row, current_column))
    
    draw_maze()
    main_window.update()
    
    main_window.after(50)
    
    if maze[current_row][current_column] == 'E':
        exit_found = True
        exit_count = exit_count + 1
        print(f"Нашел выход! Всего выходов: {exit_count}")
        return True
    
    if current_row + 1 < height: 
        if search_path(current_row + 1, current_column):
            return True
    
    if current_row - 1 >= 0:
        if search_path(current_row - 1, current_column):
            return True
    
    if current_column + 1 < width:
        if search_path(current_row, current_column + 1):
            return True
    
    if current_column - 1 >= 0:
        if search_path(current_row, current_column - 1):
            return True
    
    return False

print("=== ПРОГРАММА ПОИСКА ВЫХОДА ИЗ ЛАБИРИНТА ===")
print(f"Размер лабиринта: {height} строк, {width} столбцов")

if find_start_position():
    print("Рисую лабиринт...")
    draw_maze()
    
    print("Начинаю поиск выхода...")
    print("=" * 50)
  
    found = search_path(start_row, start_column)
    
    if found:
        print(f"Ура! Нашел хотя бы один выход!")
        print(f"Всего посещено клеток: {len(visited_cells)}")
        print(f"Найдено выходов: {exit_count}")
    else:
        print("К сожалению, выход не найден :(")
    
    print("=" * 50)
    print("Поиск завершен!")
else:
    print("Ошибка: Не удалось найти стартовую позицию!")

print("Окно открыто. Закройте окно для завершения программы.")
main_window.mainloop()
